<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Author Minty,mintyck@gmail.com"><title>Lab1 uCore Bootloader · Minty</title><meta name="description" content="Practice OneQuestion 1: how is ucore.img created?1. Why we could get more information by  make V= ?At the beginning of Makefile, we could see such def"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Minty</a></h3><div class="description"><p>Light breaks where no sun shines</p></div></div></div><ul class="social-links"><li><a href="https://mintycc.github.io"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/u/1761608703"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/mintycc"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/archives">Archive</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Lab1 uCore Bootloader</a></h3></div><div class="post-content"><h2 id="Practice-One"><a href="#Practice-One" class="headerlink" title="Practice One"></a>Practice One</h2><h3 id="Question-1-how-is-ucore-img-created"><a href="#Question-1-how-is-ucore-img-created" class="headerlink" title="Question 1: how is ucore.img created?"></a>Question 1: how is <code>ucore.img</code> created?</h3><h4 id="1-Why-we-could-get-more-information-by-make-V"><a href="#1-Why-we-could-get-more-information-by-make-V" class="headerlink" title="1. Why we could get more information by  make V= ?"></a>1. Why we could get more information by  <code>make V=</code> ?</h4><p>At the beginning of <code>Makefile</code>, we could see such definition:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V       := @</span><br></pre></td></tr></table></figure>
<p>When one line starts with <code>$(V)</code> , this line will actually start with a <code>@</code> and it will not be printed to the screen.</p>
<p>But if we type in:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make V=</span><br></pre></td></tr></table></figure>
<p>Then <code>V</code> will be blank and lines start with <code>$(V)</code> will be printed out instead.</p>
<h4 id="2-Steps-to-create-ucore-img"><a href="#2-Steps-to-create-ucore-img" class="headerlink" title="2. Steps to create ucore.img ?"></a>2. Steps to create <code>ucore.img</code> ?</h4><ol>
<li><p><code>ucore.img</code> is created by two parts: <code>kernel</code> and <code>bootlock</code> .</p>
 <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">170 UCOREIMG    := <span class="variable">$(<span class="built_in">call</span> totarget,ucore.img)</span></span><br><span class="line">171 </span><br><span class="line">172 <span class="variable">$(UCOREIMG)</span>: <span class="variable">$(kernel)</span> <span class="variable">$(bootblock)</span></span><br><span class="line">173     <span class="variable">$(V)</span>dd if=/dev/zero of=<span class="variable">$@</span> count=10000</span><br><span class="line">174     <span class="variable">$(V)</span>dd if=<span class="variable">$(bootblock)</span> of=<span class="variable">$@</span> conv=notrunc</span><br><span class="line">175     <span class="variable">$(V)</span>dd if=<span class="variable">$(kernel)</span> of=<span class="variable">$@</span> seek=1 conv=notrunc</span><br><span class="line">176 </span><br><span class="line">177 <span class="variable">$(<span class="built_in">call</span> create_target,ucore.img)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>In order to create <code>kernel</code> , these files are need: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">obj/kern/init/init.o </span><br><span class="line">obj/kern/libs/stdio.o </span><br><span class="line">obj/kern/libs/readline.o </span><br><span class="line">obj/kern/debug/panic.o </span><br><span class="line">obj/kern/debug/kdebug.o </span><br><span class="line">obj/kern/debug/kmonitor.o </span><br><span class="line">obj/kern/driver/clock.o </span><br><span class="line">obj/kern/driver/console.o </span><br><span class="line">obj/kern/driver/picirq.o </span><br><span class="line">obj/kern/driver/intr.o </span><br><span class="line">obj/kern/trap/trap.o </span><br><span class="line">obj/kern/trap/vectors.o </span><br><span class="line">obj/kern/trap/trapentry.o </span><br><span class="line">obj/kern/mm/pmm.o  </span><br><span class="line">obj/libs/string.o </span><br><span class="line">obj/libs/printfmt.o</span><br></pre></td></tr></table></figure>
<p>The command below creates these <code>*.o</code> files:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_cc,$(<span class="built_in">call</span> listf_cc,<span class="variable">$(KSRCDIR)</span>)</span>,kernel,<span class="variable">$(KCFLAGS)</span>)</span><br></pre></td></tr></table></figure>
<p><code>KINCLUDE(KCFLAGS)</code>and <code>KSRCDIR</code> include all the files need here.</p>
<p>For example, here is the command to compile <code>init.c</code> into <code>init.o</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -kern/mm/ -c kern/init/init.c -o obj/kern/init/init.o</span><br></pre></td></tr></table></figure>
<p>After we get all the <code>*.o</code> files, we can create <code>kernel</code> :</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/<span class="built_in">trap</span>/trap.o obj/kern/<span class="built_in">trap</span>/vectors.o obj/kern/<span class="built_in">trap</span>/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o</span><br></pre></td></tr></table></figure>
</li>
<li><p>Related code to create <code>bootblock</code>:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">149 bootblock = <span class="variable">$(<span class="built_in">call</span> totarget,bootblock)</span></span><br><span class="line">150 </span><br><span class="line">151 <span class="variable">$(bootblock)</span>: <span class="variable">$(<span class="built_in">call</span> toobj,<span class="variable">$(bootfiles)</span>)</span> | <span class="variable">$(<span class="built_in">call</span> totarget,sign)</span></span><br><span class="line">152     @echo + ld <span class="variable">$@</span></span><br><span class="line">153     <span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="variable">$^</span> -o <span class="variable">$(<span class="built_in">call</span> too    bj,bootblock)</span></span><br><span class="line">154     @<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,bootb    lock)</span></span><br><span class="line">155     @<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> | <span class="variable">$(SED)</span> '1,/SYMBOL TA    BLE/d; s/ .* / /; /^$$/d' &gt; <span class="variable">$(<span class="built_in">call</span> symfile,bootblock)</span></span><br><span class="line">156     @<span class="variable">$(OBJCOPY)</span> -S -O binary <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> <span class="variable">$(<span class="built_in">call</span> outfi    le,bootblock)</span></span><br><span class="line">157     @<span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span> <span class="variable">$(bootblock)</span></span><br><span class="line">158 </span><br><span class="line">159 <span class="variable">$(<span class="built_in">call</span> create_target,bootblock)</span></span><br></pre></td></tr></table></figure>
<p>In order to create <code>bootblock</code>, we need <code>bootasm.o</code>, <code>bootmain.o</code> and <code>sign.c</code> :</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br></pre></td></tr></table></figure>
<p><code>bootasm.o</code> and <code>bootmain.o</code> is created by:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">146 bootfiles = <span class="variable">$(<span class="built_in">call</span> listf_cc,boot)</span></span><br><span class="line">147 <span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(bootfiles)</span>,$(<span class="built_in">call</span> cc_compile,<span class="variable">$(f)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> -Os     -nostdinc)</span>)</span><br></pre></td></tr></table></figure>
<p>Command to compile <code>bootsam.S</code> into <code>bootasm.o</code> :</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br></pre></td></tr></table></figure>
<p>Command to compile <code>bootmain.c</code> into <code>bootmain.o</code> :</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br></pre></td></tr></table></figure>
<p>Create <code>sign</code> tools:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">164 <span class="variable">$(<span class="built_in">call</span> add_files_host,tools/sign.c,sign,sign)</span></span><br><span class="line">165 <span class="variable">$(<span class="built_in">call</span> create_target_host,sign,sign)</span></span><br></pre></td></tr></table></figure>
<p>Copy binary code from <code>bootblock.o</code> to <code>bootblock.out</code> :</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objcopy -S -O binary obj/bootblock.o obj/bootblock.out</span><br></pre></td></tr></table></figure>
<p>Use <code>sign</code> tool to convert <code>bootblock.out</code> to <code>bootblock</code> :</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/sign obj/bootblock.out bin/bootblock</span><br></pre></td></tr></table></figure>
</li>
<li><p>Create one empty <code>ucore.img</code> file with 10000 blocks filled with 0. Default size of each block is 512 bytes. </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=bin/ucore.img count=10000</span><br></pre></td></tr></table></figure>
<p>Copy <code>bootblock</code> to the first block :</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=bin/bootblock of=bin/ucore.img conv=notrunc</span><br></pre></td></tr></table></figure>
<p>Write kernel start from the second block :</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Question-2-properties-as-a-legal-bootloader-block"><a href="#Question-2-properties-as-a-legal-bootloader-block" class="headerlink" title="Question 2: properties as a legal bootloader block?"></a>Question 2: properties as a legal bootloader block?</h3><h4 id="1-bootlock-out-size-should-be-smaller-or-equal-to-510-bytes"><a href="#1-bootlock-out-size-should-be-smaller-or-equal-to-510-bytes" class="headerlink" title="1. bootlock.out size should be smaller or equal to 510 bytes"></a>1. <code>bootlock.out</code> size should be smaller or equal to 510 bytes</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>     <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) &#123;</span><br><span class="line"><span class="number">19</span>         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%lld &gt;&gt; 510!!\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line"><span class="number">20</span>         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">21</span>     &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-Set-the-value-of-last-two-bytes"><a href="#2-Set-the-value-of-last-two-bytes" class="headerlink" title="2. Set the value of last two bytes"></a>2. Set the value of last two bytes</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31</span>     buf[<span class="number">510</span>] = <span class="number">0x55</span>;</span><br><span class="line"><span class="number">32</span>     buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</span><br></pre></td></tr></table></figure>
<p>Then the <code>bootblock</code> will be exactly 512 bytes long, and the last two bytes become a sign for a legal bootloader block.</p>
<h2 id="Practice-Two"><a href="#Practice-Two" class="headerlink" title="Practice Two"></a>Practice Two</h2><h3 id="Question-1-singlestep-BIOS-after-CPU-powered"><a href="#Question-1-singlestep-BIOS-after-CPU-powered" class="headerlink" title="Question 1: singlestep BIOS after CPU powered."></a>Question 1: singlestep BIOS after CPU powered.</h3><ol>
<li><p>Edit the code in <code>/tools/gdbinit</code> which will make qemu wait for gdb’s control after start</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set architecture i8086</span><br><span class="line">target remote :1234</span><br></pre></td></tr></table></figure>
</li>
<li><p>Then run qemu + gdb under ‘lab1’ directory:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make debug</span><br></pre></td></tr></table></figure>
</li>
<li><p>Use <code>si</code> to singlestep.</p>
</li>
<li><p>We could print out the first instruction executed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /2i 0x000ffff0</span><br><span class="line">   0xffff0:     ljmp   $0xf000,$0xe05b</span><br><span class="line">   0xffff5:     xor    %dh,0x322f</span><br></pre></td></tr></table></figure>
</li>
<li><p>We could see the first <code>$PC</code> is <code>0x0000fff0</code>, however this value is actually <code>$EIP</code>. We could tell this after one singlestep:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000e05b in ?? ()</span><br></pre></td></tr></table></figure>
<p><code>$EIP</code> jumps to <code>0x0000e05b</code>, as the first instruction means. </p>
<p>The value of <code>$CS</code> is <code>0x0000f000</code> at this time, and we could get <code>PC = CS  * 16 + EIP = 0x000ffff0</code>.</p>
</li>
</ol>
<h3 id="Question-2-set-breakpoint-at-0x7c00"><a href="#Question-2-set-breakpoint-at-0x7c00" class="headerlink" title="Question 2: set breakpoint at 0x7c00."></a>Question 2: set breakpoint at <code>0x7c00</code>.</h3><ol>
<li><p>Edit <code>tools/gdbinit</code> :</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 <span class="built_in">set</span> architecture i8086</span><br><span class="line">2 target remote :1234</span><br><span class="line">3 b *0x7c00</span><br><span class="line">4 <span class="built_in">continue</span></span><br><span class="line">5 x /10i <span class="variable">$pc</span></span><br><span class="line">6 <span class="built_in">set</span> architecture i386</span><br></pre></td></tr></table></figure>
</li>
<li><p>Run qemu:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make debug</span><br></pre></td></tr></table></figure>
</li>
<li><p>Get instructions start from <code>0x7c00</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x7c00:      cli</span><br><span class="line">   0x7c01:      cld</span><br><span class="line">   0x7c02:      xor    %ax,%ax</span><br><span class="line">   0x7c04:      mov    %ax,%ds</span><br><span class="line">   0x7c06:      mov    %ax,%es</span><br><span class="line">   0x7c08:      mov    %ax,%ss</span><br><span class="line">   0x7c0a:      in     $0x64,%al</span><br><span class="line">   0x7c0c:      test   $0x2,%al</span><br><span class="line">   0x7c0e:      jne    0x7c0a</span><br><span class="line">   0x7c10:      mov    $0xd1,%al</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Question-3-compare-the-code-to-bootasm-S-and-bootmain-asm"><a href="#Question-3-compare-the-code-to-bootasm-S-and-bootmain-asm" class="headerlink" title="Question 3: compare the code to bootasm.S and bootmain.asm."></a>Question 3: compare the code to <code>bootasm.S</code> and <code>bootmain.asm</code>.</h3><p>They are the same.</p>
<h2 id="Practice-Three"><a href="#Practice-Three" class="headerlink" title="Practice Three"></a>Practice Three</h2><h3 id="Question-1-how-to-turn-on-A20"><a href="#Question-1-how-to-turn-on-A20" class="headerlink" title="Question 1: how to turn on A20?"></a>Question 1: how to turn on A20?</h3><h4 id="1-Material"><a href="#1-Material" class="headerlink" title="1. Material"></a>1. Material</h4><p>About <a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_appendix_a20.html" target="_blank" rel="noopener">A20 gate</a>.</p>
<p>Due to some history reasons, A20 is controlled by one port on 8042 keyboard controller, though A20 has nothing to do with keyboard control.</p>
<h4 id="2-Analysis"><a href="#2-Analysis" class="headerlink" title="2. Analysis"></a>2. Analysis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">29 seta20.1:</span><br><span class="line">30     inb $0x64, %al		# fetch Status Register from 0x64</span><br><span class="line">31     testb $0x2, %al		# check if input register is empty</span><br><span class="line">32     jnz seta20.1</span><br><span class="line">33 </span><br><span class="line">34     movb $0xd1, %al 	# output 0xd1 to 0x64 port</span><br><span class="line">35     outb %al, $0x64		# prepare to write Output Port</span><br><span class="line">36 </span><br><span class="line">37 seta20.2:</span><br><span class="line">38     inb $0x64, %al 		# same as above</span><br><span class="line">39     testb $0x2, %al</span><br><span class="line">40     jnz seta20.2</span><br><span class="line">41 </span><br><span class="line">42     movb $0xdf, %al		# output 0xdf to output port</span><br><span class="line">43     outb %al, $0x60		# 0xdf = 11011111 with A20 set</span><br></pre></td></tr></table></figure>
<h3 id="Question-2-how-to-initialize-GDT"><a href="#Question-2-how-to-initialize-GDT" class="headerlink" title="Question 2: how to initialize GDT?"></a>Question 2: how to initialize GDT?</h3><ol>
<li><p>Load new GDT:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49     lgdt gdtdesc</span><br></pre></td></tr></table></figure>
</li>
<li><p>New GDT is defined as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">78 .p2align 2</span><br><span class="line">79 gdt:</span><br><span class="line">80     SEG_NULLASM		# null seg</span><br><span class="line">81     SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff) 	</span><br><span class="line"># code seg for bootloader and kernel</span><br><span class="line">82     SEG_ASM(STA_W, 0x0, 0xffffffff)			</span><br><span class="line"># data seg for bootloader and kernel</span><br><span class="line">83 </span><br><span class="line">84 gdtdesc:</span><br><span class="line">85     .word 0x17 		# sizeof(gdt) - 1</span><br><span class="line">86     .long gdt 		# address gdt</span><br></pre></td></tr></table></figure>
<p>Here, the first segment is  null according to 80386 structure.</p>
<p>The second segment is code segment, and the third one is data segment.</p>
</li>
<li><p>Update CS, DS and other segments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">56     ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line">57 </span><br><span class="line">58 .code32 		# Assemble for     32-bit mode</span><br><span class="line">59 protcseg:</span><br><span class="line">60     # Set up the protected-mode data segment registers</span><br><span class="line">61     movw $PROT_MODE_DSEG, %ax</span><br><span class="line">62     movw %ax, %ds 	# -&gt; DS: Data S    egment</span><br><span class="line">63     movw %ax, %es 	# -&gt; ES: Extra     Segment</span><br><span class="line">64     movw %ax, %fs 	# -&gt; FS</span><br><span class="line">65     movw %ax, %gs 	# -&gt; GS</span><br><span class="line">66     movw %ax, %ss 	# -&gt; SS: Stack     Segment</span><br></pre></td></tr></table></figure>
</li>
<li><p>Notice the definition of <code>PROT_MODE_CSEG</code> and <code>PROT_MODE_DSEG</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 .set PROT_MODE_CSEG, 0x8 # kernel code segment selector</span><br><span class="line">9 .set PROT_MODE_DSEG, 0x10# kernel data segment selector</span><br></pre></td></tr></table></figure>
<p>According to the structure of selector, the last three bits are not for index. So actually these two point to the first and second segment in GDT (the 0 segment is null), in other words, the two segment we just initialized.</p>
</li>
</ol>
<h3 id="Question-3-how-to-enable-and-enter-protect-mode"><a href="#Question-3-how-to-enable-and-enter-protect-mode" class="headerlink" title="Question 3: how to enable and enter protect mode?"></a>Question 3: how to enable and enter protect mode?</h3><p>This one is easy, just set the PE bit of <code>cr0</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">50     movl %cr0, %eax</span><br><span class="line">51     orl $CR0_PE_ON, %eax</span><br><span class="line">52     movl %eax, %cr0</span><br></pre></td></tr></table></figure>
<h2 id="Practice-Four"><a href="#Practice-Four" class="headerlink" title="Practice Four"></a>Practice Four</h2><h3 id="Question-1-how-does-bootloader-read-disk-block"><a href="#Question-1-how-does-bootloader-read-disk-block" class="headerlink" title="Question 1: how does bootloader read disk block?"></a>Question 1: how does <code>bootloader</code> read disk block?</h3><h4 id="1-Material-1"><a href="#1-Material-1" class="headerlink" title="1. Material:"></a>1. Material:</h4><ol>
<li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_3_dist_accessing.html" target="_blank" rel="noopener">Disk I/O</a>.</li>
</ol>
<h4 id="2-Analysis-1"><a href="#2-Analysis-1" class="headerlink" title="2. Analysis:"></a>2. Analysis:</h4><ol>
<li><p>Call from the <code>void bootmain(void)</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>readseg()</code> read <code>count</code> bytes start from <code>offset</code> and store them to <code>va</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readseg(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// round down to sector boundary</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">    <span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></span><br><span class="line">    <span class="comment">// we load in increasing order.</span></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((<span class="keyword">void</span> *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readsect()</code> is called in the function.</p>
</li>
<li><p><code>readsect()</code> read one sector at <code>secno</code> from the disk to <code>dst</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readsect(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno) &#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can refer to material part to see how disk I/O works</span></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);                         <span class="comment">// count = 1</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);                      <span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>I am not so sure how does <code>waitdisk()</code> work yet:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">waitdisk(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Question-2-how-does-bootloader-load-kernel-in-ELF-format"><a href="#Question-2-how-does-bootloader-load-kernel-in-ELF-format" class="headerlink" title="Question 2: how does bootloader load kernel in ELF format?"></a>Question 2: how does <code>bootloader</code> load <code>kernel</code> in ELF format?</h3><h4 id="1-Material-2"><a href="#1-Material-2" class="headerlink" title="1. Material:"></a>1. Material:</h4><ol>
<li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_4_elf.html" target="_blank" rel="noopener">ELF file</a> (uCore lab guide).</li>
<li><a href="https://my.oschina.net/AandroidD/blog/313186" target="_blank" rel="noopener">ELF file 1</a>, <a href="https://my.oschina.net/AandroidD/blog/313905" target="_blank" rel="noopener">ELF file 2</a>.</li>
<li><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch18s05.html" target="_blank" rel="noopener">ELF file</a> (recommended).</li>
</ol>
<h4 id="2-Analysis-2"><a href="#2-Analysis-2" class="headerlink" title="2. Analysis:"></a>2. Analysis:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">bootmain(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// explained above</span></span><br><span class="line">    readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ELF's e_magic must be ELF_MAGIC to be legal</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// find program header table according to header files in ELF</span></span><br><span class="line">    ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="comment">// read each segment out to its signed virtual address</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enter kernel according to entry point get from the ELF header</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Practice-Five"><a href="#Practice-Five" class="headerlink" title="Practice Five"></a>Practice Five</h2><h3 id="Question-1-implement-print-stackframe"><a href="#Question-1-implement-print-stackframe" class="headerlink" title="Question 1: implement print_stackframe() :"></a>Question 1: implement <code>print_stackframe()</code> :</h3><h4 id="1-Material-3"><a href="#1-Material-3" class="headerlink" title="1. Material:"></a>1. Material:</h4><ol>
<li>Video: <a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/courseware/eeab809fe92d45549033de97f84d8a7c/1f400e2ebe1148348adebe355cb2ea0b/" target="_blank" rel="noopener">4.2 The implementation of C function call</a>.</li>
<li>Lab guide: <a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_3_1_function_stack.html" target="_blank" rel="noopener">Function stack</a>. Video is much clearer than lab guide.</li>
</ol>
<h4 id="2-Implementation"><a href="#2-Implementation" class="headerlink" title="2. Implementation:"></a>2. Implementation:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">print_stackframe(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp = read_ebp();</span><br><span class="line">    <span class="keyword">uint32_t</span> eip = read_eip();</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; ebp != <span class="number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i ++ ) &#123;</span><br><span class="line">        cprintf(<span class="string">"ebp:0x%08x eip:0x%08x args:"</span>, ebp, eip);</span><br><span class="line">        <span class="keyword">uint32_t</span> *args = (<span class="keyword">uint32_t</span> *)ebp + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++)</span><br><span class="line">            cprintf(<span class="string">"0x%08x "</span>, args[j]);</span><br><span class="line">        cprintf(<span class="string">"\n"</span>);</span><br><span class="line">        </span><br><span class="line">        print_debuginfo(eip - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        eip = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">1</span>];</span><br><span class="line">        ebp = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-Difference-between-uint32-t-ebp-2-and-uint32-t-ebp-2"><a href="#3-Difference-between-uint32-t-ebp-2-and-uint32-t-ebp-2" class="headerlink" title="3. Difference between (uint32_t *)ebp + 2 and ((uint32_t *)ebp)[2] ?"></a>3. Difference between <code>(uint32_t *)ebp + 2</code> and <code>((uint32_t *)ebp)[2]</code> ?</h4><p>Answer comes from <a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=1117" target="_blank" rel="noopener">piazza</a>.</p>
<ol>
<li><code>(uint32_t *)ebp + 2</code> means the address of <code>ebp</code> plus 2 * 4 (the size of pointer is 4 bytes), the answer is address;</li>
<li><code>((uint32_t *)ebp)[2]</code> fetches the value, which equals to <code>*((uint32_t *)ebp + 2)</code>.</li>
</ol>
<h3 id="Question-2-explain-the-last-line-of-output"><a href="#Question-2-explain-the-last-line-of-output" class="headerlink" title="Question 2: explain the last line of output."></a>Question 2: explain the last line of output.</h3><p>The last line of output is :</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ebp:0x00007bf8 eip:0x00007d66 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8</span><br></pre></td></tr></table></figure>
<p>From <code>bootasm.S</code> we know the initial value of <code>ebp</code> and <code>eip</code> are :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    call bootmain</span><br></pre></td></tr></table></figure>
<p>The value of <code>ebp</code> is 0 and value of <code>esp</code> is <code>0x7c00</code>. When call <code>bootmain</code>, push old <code>ebp</code> in, push return address in. Each pointer is 4 bytes long, so the value of <code>esp</code> now is <code>0x7bf8</code>. <code>ebp = esp</code>, so <code>ebp</code> equals to <code>0x7bf8</code>.</p>
<h2 id="Practice-Six"><a href="#Practice-Six" class="headerlink" title="Practice Six"></a>Practice Six</h2><h3 id="Question-1-how-long-is-one-descriptor-in-IDT-which-bit-represents-the-entry-to-handler"><a href="#Question-1-how-long-is-one-descriptor-in-IDT-which-bit-represents-the-entry-to-handler" class="headerlink" title="Question 1: how long is one descriptor in IDT? which bit represents the entry to handler?"></a>Question 1: how long is one descriptor in <code>IDT</code>? which bit represents the entry to handler?</h3><h4 id="1-Material-4"><a href="#1-Material-4" class="headerlink" title="1. Material:"></a>1. Material:</h4><ol>
<li><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_3_2_interrupt_exception.html" target="_blank" rel="noopener">Interrupt and exception</a>.</li>
</ol>
<h4 id="2-Answer"><a href="#2-Answer" class="headerlink" title="2. Answer:"></a>2. Answer:</h4><ol>
<li>The size of one descriptor is 8 bytes.</li>
<li>16-31 bits represents the <code>selector</code>, and 0-15 with 63-48 bits together represent <code>offset</code>. <code>selector</code> and <code>offset</code> together points to the handler.</li>
</ol>
<h3 id="Question-2-complete-idt-init-in-kern-trap-trap-c"><a href="#Question-2-complete-idt-init-in-kern-trap-trap-c" class="headerlink" title="Question 2: complete idt_init() in kern/trap/trap.c."></a>Question 2: complete <code>idt_init()</code> in <code>kern/trap/trap.c</code>.</h3><h4 id="1-Material-5"><a href="#1-Material-5" class="headerlink" title="1. Material:"></a>1. Material:</h4><ol>
<li><a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=1009" target="_blank" rel="noopener">Piazza Q&amp;A</a> clear explanation and great example.</li>
<li><a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=102" target="_blank" rel="noopener">Piazza Q&amp;A 2</a>.</li>
<li><a href="http://www.cnblogs.com/pang123hui/archive/2010/11/27/2309924.html" target="_blank" rel="noopener">Blog1</a>, <a href="https://blog.csdn.net/better0332/article/details/3416749" target="_blank" rel="noopener">Blog2</a>.</li>
</ol>
<h4 id="2-Implementation-1"><a href="#2-Implementation-1" class="headerlink" title="2. Implementation:"></a>2. Implementation:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">idt_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i ++) &#123;</span><br><span class="line">    	<span class="comment">// system call</span></span><br><span class="line">        <span class="keyword">if</span> (i == T_SYSCALL) &#123;</span><br><span class="line">            SETGATE(idt[i], <span class="number">1</span>, GD_KTEXT, __vectors[i], DPL_USER);</span><br><span class="line">        <span class="comment">// system reserved part</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; IRQ_OFFSET) &#123;</span><br><span class="line">            SETGATE(idt[i], <span class="number">1</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">        <span class="comment">// user defined</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// load IDT</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The value of  <code>GD_KTEXT</code> is 8, this pointer points to <code>GDT</code>.</p>
<h3 id="Question-3-complete-trap-in-trap-c"><a href="#Question-3-complete-trap-in-trap-c" class="headerlink" title="Question 3: complete trap() in trap.c ."></a>Question 3: complete <code>trap()</code> in <code>trap.c</code> .</h3><p>Question 3 is quite easy:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">	ticks ++; <span class="comment">// ticks is an external variable</span></span><br><span class="line">	<span class="keyword">if</span> (ticks % TICK_NUM == <span class="number">0</span>) &#123;</span><br><span class="line">        print_ticks();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Challenge-One"><a href="#Challenge-One" class="headerlink" title="Challenge One"></a>Challenge One</h2><h3 id="Question-switch-between-user-mode-and-kernel-mode"><a href="#Question-switch-between-user-mode-and-kernel-mode" class="headerlink" title="Question: switch between user mode and kernel mode."></a>Question: switch between user mode and kernel mode.</h3><h4 id="1-Material-6"><a href="#1-Material-6" class="headerlink" title="1. Material:"></a>1. Material:</h4><ol>
<li><a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=306" target="_blank" rel="noopener">Piazza Q&amp;A 1</a>.</li>
<li><a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=122" target="_blank" rel="noopener">Piazza Q&amp;A 2</a>.</li>
</ol>
<h4 id="2-Implementation-2"><a href="#2-Implementation-2" class="headerlink" title="2. Implementation:"></a>2. Implementation:</h4><ol>
<li><p>Switch from kernel to user:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">lab1_switch_to_user(<span class="keyword">void</span>) &#123;</span><br><span class="line">	<span class="comment">// we dont have esp and ss stored in stack</span></span><br><span class="line">	<span class="comment">// so we need to push two null items in esp to stop damage from pop</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"sub $0x8, %%esp \n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int %0 \n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"movl %%ebp, %%esp \n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        :</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"i"</span>(T_SWITCH_TOU)</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trap.c</span></span><br><span class="line"><span class="keyword">case</span> T_SWITCH_TOU:</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_cs != USER_CS) &#123;</span><br><span class="line">        <span class="comment">// switchk2u is a temporary trapframe to replace tf</span></span><br><span class="line">        switchk2u = *tf;</span><br><span class="line">        switchk2u.tf_cs = USER_CS;</span><br><span class="line">        switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;</span><br><span class="line">        <span class="comment">// esp points to element after tf</span></span><br><span class="line">        switchk2u.tf_esp = (<span class="keyword">uint32_t</span>)tf + <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>;</span><br><span class="line">        switchk2u.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">        <span class="comment">// esp push and pop in trapentry.S, so esp is actually a pointer here</span></span><br><span class="line">        <span class="comment">// when esp is pop, it will points to switchk2u instead of tf</span></span><br><span class="line">        <span class="comment">// then after iter, tf_esp will be poped, the value of esp will be normal</span></span><br><span class="line">        *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)&amp;switchk2u;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Switch from user to kernel:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">lab1_switch_to_kernel(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int %0 \n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"movl %%ebp, %%esp \n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        :</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"i"</span>(T_SWITCH_TOK)</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trap.c</span></span><br><span class="line"><span class="keyword">case</span> T_SWITCH_TOK:</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">        tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">        tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">        tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">        <span class="comment">// what we do here is delete esp and ss in tf</span></span><br><span class="line">        <span class="comment">// then move tf back 8 bytes (2 blocks in stack)</span></span><br><span class="line">        switchu2k = (struct trapframe *)(tf-&gt;tf_esp - <span class="keyword">sizeof</span>(struct trapframe) + <span class="number">8</span>);</span><br><span class="line">        memmove(switchu2k, tf, <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>);</span><br><span class="line">        *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)switchu2k;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Challenge-Two"><a href="#Challenge-Two" class="headerlink" title="Challenge Two"></a>Challenge Two</h2><h3 id="Question-keyboard-press-‘0’-kernel-mode-press-‘1’-user-mode"><a href="#Question-keyboard-press-‘0’-kernel-mode-press-‘1’-user-mode" class="headerlink" title="Question: keyboard press ‘0’ kernel mode, press ‘1’ user mode."></a>Question: keyboard press ‘0’ kernel mode, press ‘1’ user mode.</h3><p>Just add treatment after ‘keyboard interrupt’ case, borrow code from ‘Challenge One’:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD:</span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">"kbd [%03d] %c\n"</span>, c, c);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tf-&gt;tf_cs != USER_CS) &#123;</span><br><span class="line">                switchk2u = *tf;</span><br><span class="line">                switchk2u.tf_cs = USER_CS;</span><br><span class="line">                switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;</span><br><span class="line">                switchk2u.tf_esp = (<span class="keyword">uint32_t</span>)tf + <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>;</span><br><span class="line">                switchk2u.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">                *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)&amp;switchk2u;</span><br><span class="line">                print_trapframe(tf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'3'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">                tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">                tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">                tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">                switchu2k = (struct trapframe *)(tf-&gt;tf_esp - <span class="keyword">sizeof</span>(struct trapframe) + <span class="number">8</span>);</span><br><span class="line">                memmove(switchu2k, tf, <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>);</span><br><span class="line">                *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)switchu2k;</span><br><span class="line">                print_trapframe(tf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Problems-I-ran-into"><a href="#Problems-I-ran-into" class="headerlink" title="Problems I ran into"></a>Problems I ran into</h2><h3 id="1-Ubuntu-18-04-LTS-with-wrong-bootblock-out-size"><a href="#1-Ubuntu-18-04-LTS-with-wrong-bootblock-out-size" class="headerlink" title="1. Ubuntu 18.04 LTS with wrong bootblock.out size."></a>1. Ubuntu 18.04 LTS with wrong <code>bootblock.out</code> size.</h3><p>Size of the <code>bootblock.out</code> created will be 600 bytes, larger than 510 bytes.</p>
<p>Solution from <a href="https://chyyuu.gitbooks.io/os_course_qa/content/02-interrupt-exception-syscall.html" target="_blank" rel="noopener">Q&amp;A</a>.</p>
<p>It is because the new version gcc generate extra code in the execution code. Three ways to solve:</p>
<ol>
<li>Add <code>gcc -Os</code> in <code>Makefile</code> to reduce code size.</li>
<li>Use an older version of gcc.</li>
<li>Use the offered ubuntu image.</li>
</ol>
<p>Solution 1 doesn’t work for me. Then I try to install an older version of gcc. I have tested gcc-5 and gcc-7 with both <code>bootblock.out</code> file larger than acceptable. Finally I figured out gcc-4 will be the right version.</p>
<p>However, Ubuntu 18.04 doesn’t support gcc-4 very well. I have nearly tried every way to install gcc-4 but the only result is failure.</p>
<p>And the reason I didn’t use the provided image or use Ubuntu 14.04 was the performance of this system running on my VirtualBox was so poor that the latency was barely bearable. </p>
<p>At last, I switched to Ubuntu 16.04 and installed gcc-4.9 successfully through <code>apt-get</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install gcc-4.9</span><br></pre></td></tr></table></figure>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-05-15</span><i class="fa fa-tag"></i><a class="tag" href="/tags/OS/" title="OS">OS </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://mintycc.github.io/2018/05/15/Lab1-uCore-Bootloader/,Minty,Lab1 uCore Bootloader,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/05/15/Lab0-uCore-Preparation/" title="Lab0 uCore Preparation">next_post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>